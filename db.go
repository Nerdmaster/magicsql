// Package magicsql is a wrapper around a database handle with added magic
// to ease common SQL operations, and reflection for automatic reading and
// writing of data
package magicsql

import (
	"database/sql"
	"reflect"
	"sync"
)

type errorable interface {
	Err() error
	SetErr(error)
}

// DB wraps an sql.DB, providing the Operation spawner for deferred-error
// database operations.  Like sql.DB, this DB type is meant to live more or
// less globally and be a long-living object.
type DB struct {
	db      *sql.DB
	typemap map[reflect.Type]*magicTable
	namemap map[string]*magicTable
	m       sync.RWMutex
}

// Open attempts to connect to a database, wrapping the sql.Open call,
// returning the new magicsql.DB and error if any.  This isn't storing the
// error for later, as there's nothing which can happen if the database can't
// be opened.
func Open(driverName, dataSourceName string) (*DB, error) {
	var sqldb, err = sql.Open(driverName, dataSourceName)
	if err != nil {
		return nil, err
	}
	return Wrap(sqldb), nil
}

// Wrap is used to create a new DB from an existing connection
func Wrap(db *sql.DB) *DB {
	return &DB{
		db:      db,
		typemap: make(map[reflect.Type]*magicTable),
		namemap: make(map[string]*magicTable),
	}
}

// DataSource returns the underlying sql.DB pointer so the caller can do
// lower-level work which isn't wrapped in this package
func (db *DB) DataSource() *sql.DB {
	return db.db
}

// RegisterTable registers a table structure using NewMagicTable, then stores
// the table for lookup in an Operation's helper functions
//
// The structure returned by the generator must have tags for explicit table
// names, or else a lowercased version of the field name will be inferred.  Tag
// names must be in the form `sql:"field_name"`.  A field name of "-" tells the
// package to skip that field.  If there's a single primary key, insert and
// update statements can be automatically generated by specifying ",primary"
// after the field name.  e.g., `sql:"field_name,primary"`.  Non-exported
// fields are skipped.
func (db *DB) RegisterTable(tableName string, generator func() interface{}) {
	var t = NewMagicTable(tableName, generator)

	db.m.Lock()
	defer db.m.Unlock()
	db.typemap[t.RType] = t
	db.namemap[tableName] = t
}

// findTableByName looks up the table by its name, for use in creating SQL queries
// and putting data into structures
func (db *DB) findTableByName(tableName string) *magicTable {
	db.m.RLock()
	defer db.m.RUnlock()

	return db.namemap[tableName]
}

// findTableByType looks up the table by a reflection type
func (db *DB) findTableByType(t reflect.Type) *magicTable {
	db.m.RLock()
	defer db.m.RUnlock()

	return db.typemap[t]
}

// Operation returns an Operation instance, suitable for a short-lived task.
// This is the entry point for any of the sql wrapped magic.  An Operation
// should be considered a short-lived object which is not safe for concurrent
// access since it needs to be able to halt on any error with any operation it
// performs.  Concurrent access could be extremely confusing in this context
// due to the possibility of Operation.Err() returning an error from a
// different goroutine than the one doing the checking.
func (db *DB) Operation() *Operation {
	return &Operation{parent: db, db: db.db}
}
